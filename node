Motion update:
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/imu.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "eufs_msgs/msg/wheel_speeds_stamped.hpp"
#include "tf2/LinearMath/Quaternion.h"
#include <cmath>

class PoseEstimator : public rclcpp::Node {
public:
    PoseEstimator() : Node("pose_estimator") {
        imu_sub_ = this->create_subscription<sensor_msgs::msg::Imu>(
            "/imu", 10, std::bind(&PoseEstimator::imu_callback, this, std::placeholders::_1));

        wheel_sub_ = this->create_subscription<eufs_msgs::msg::WheelSpeedsStamped>(
            "/ros_can/wheel_speeds", 10, std::bind(&PoseEstimator::wheel_callback, this, std::placeholders::_1));

        pose_pub_ = this->create_publisher<geometry_msgs::msg::PoseStamped>("/prediction_pose", 10);

        RCLCPP_INFO(this->get_logger(), "PoseEstimator node initialized and subscribed to topics.");

        prev_time_ = this->now();
    }

private:
    // Subscribers and publisher
    rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_sub_;
    rclcpp::Subscription<eufs_msgs::msg::WheelSpeedsStamped>::SharedPtr wheel_sub_;
    rclcpp::Publisher<geometry_msgs::msg::PoseStamped>::SharedPtr pose_pub_;

    // Pose state
    double x_ = 0.0, y_ = 0.0, yaw_ = 0.0;
    double vx_ = 0.0, vy_ = 0.0, yaw_rate_ = 0.0;

    // Constants
    const double rwheel_ = 0.25;
    const double gear_ratio_ = 60.0;

    // Time tracking
    rclcpp::Time prev_time_;

    void wheel_callback(const eufs_msgs::msg::WheelSpeedsStamped::SharedPtr msg) {
        double lb = msg->speeds.lb_speed;
        double rb = msg->speeds.rb_speed;
        double avg_speed = (lb + rb) / 2.0;

        vx_ = M_PI * rwheel_ * avg_speed / gear_ratio_;

        updatePose(this->now());
        RCLCPP_INFO(this->get_logger(), "Wheel callback processed.");
    }

    void imu_callback(const sensor_msgs::msg::Imu::SharedPtr msg) {
        yaw_rate_ = msg->angular_velocity.z;
        // RCLCPP_INFO(this->get_logger(), "IMU callback processed.");
    }

    void updatePose(rclcpp::Time current_time) {
        if (prev_time_.nanoseconds() == 0) {
            prev_time_ = current_time;
            RCLCPP_INFO(this->get_logger(), "First update, initializing prev_time_.");
            return;
        }

        double dt = (current_time - prev_time_).seconds();

        if (dt <= 0.0) {
            RCLCPP_WARN(this->get_logger(), "Skipping update due to non-positive dt: %.6f", dt);
            return;
        }

        double dx = std::cos(yaw_) * vx_ * dt;
        double dy = std::sin(yaw_) * vx_ * dt;
        double dyaw = yaw_rate_ * dt;

        x_ += dx;
        y_ += dy;
        yaw_ += dyaw;
        yaw_ = std::atan2(std::sin(yaw_), std::cos(yaw_));  // Normalize angle

        geometry_msgs::msg::PoseStamped pose_msg;
        pose_msg.header.stamp = current_time;
        pose_msg.header.frame_id = "base_footprint";
        pose_msg.pose.position.x = x_;
        pose_msg.pose.position.y = y_;
        pose_msg.pose.position.z = 0.0;

        tf2::Quaternion q;
        q.setRPY(0, 0, yaw_);
        pose_msg.pose.orientation.x = q.x();
        pose_msg.pose.orientation.y = q.y();
        pose_msg.pose.orientation.z = q.z();
        pose_msg.pose.orientation.w = q.w();

        RCLCPP_INFO(this->get_logger(), "current_time = %.6f, prev_time = %.6f",
                    current_time.seconds(), prev_time_.seconds());

        pose_pub_->publish(pose_msg);

        RCLCPP_INFO(this->get_logger(), "Published pose: x=%.2f, y=%.2f, yaw=%.2f", x_, y_, yaw_);

        prev_time_ = current_time;
    }
};

int main(int argc, char *argv[]) {
    rclcpp::init(argc, argv);
    rclcpp::spin(std::make_shared<PoseEstimator>());
    rclcpp::shutdown();
    return 0;
}


Node:
#include <chrono>
#include <functional>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/float32_multi_array.hpp"
#include "sensor_msgs/msg/imu.hpp"
#include "eufs_msgs/msg/wheel_speeds_stamped.hpp"
#include "eufs_msgs/msg/car_state.hpp"

using std::placeholders::_1;
using namespace std::chrono_literals;

class Localizer : public rclcpp::Node
{
public:
  Localizer() : Node("minimal_publisher"), count_(0)
  {
    publisher_ = this->create_publisher<std_msgs::msg::Float32MultiArray>("current_pose", 10);

    imu_subscription_ = this->create_subscription<sensor_msgs::msg::Imu>(
      "/imu", 10, std::bind(&Localizer::topic_callback1, this, _1));

    gr_subscription_ = this->create_subscription<eufs_msgs::msg::WheelSpeedsStamped>(
      "/ros_can/wheel_speeds", 10, std::bind(&Localizer::topic_callback2, this, _1));

    re_subscription_ = this->create_subscription<eufs_msgs::msg::CarState>(
      "/ground_truth/state", 10, std::bind(&Localizer::topic_callback3, this, _1));

    timer_ = this->create_wall_timer(1ms, std::bind(&Localizer::timer_callback, this));
  }

private:
  void topic_callback1(const sensor_msgs::msg::Imu::SharedPtr msg)
  {
    w = msg->angular_velocity.z;
    RCLCPP_INFO(this->get_logger(), "IMU angular velocity z: %.2f", w);
  }

  void topic_callback2(const eufs_msgs::msg::WheelSpeedsStamped::SharedPtr msg)
  {
    RCLCPP_INFO(this->get_logger(), "WheelSpeeds callback triggered");
    vrl = msg->speeds.lb_speed;
    vrr = msg->speeds.rb_speed;
    vx = (3.14 * 0.25) * (vrr + vrl) / 60.0;  // Assume wheel radius = 0.25 m
    vy = 0.0;
  }

  void topic_callback3(const eufs_msgs::msg::CarState::SharedPtr msg)
  {
    real_x = msg->pose.pose.position.x;
    real_y = msg->pose.pose.position.y;
  }

  void timer_callback()
  {
    x_t += 0.001 * (cos(phi_t) * vx - sin(phi_t) * vy);
    y_t += 0.001 * (cos(phi_t) * vy + sin(phi_t) * vx);
    phi_t += w * 0.001;

    auto message = std_msgs::msg::Float32MultiArray();
    message.data.push_back(x_t);
    message.data.push_back(y_t);
    message.data.push_back(real_x);
    message.data.push_back(real_y);

    RCLCPP_INFO(this->get_logger(), "Publishing pose: [%.2f, %.2f, %.2f]", x_t, y_t, phi_t);
    publisher_->publish(message);
  }

  rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr imu_subscription_;
  rclcpp::Subscription<eufs_msgs::msg::WheelSpeedsStamped>::SharedPtr gr_subscription_;
  rclcpp::Subscription<eufs_msgs::msg::CarState>::SharedPtr re_subscription_;
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Publisher<std_msgs::msg::Float32MultiArray>::SharedPtr publisher_;
  size_t count_;

  float x_t = 0.0, y_t = 0.0, phi_t = 0.0, real_x = 0.0, real_y = 0.0;
  float vx = 0.0, vy = 0.0, w = 0.0, vrr = 0.0, vrl = 0.0;
};

int main(int argc, char * argv[])
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<Localizer>());
  rclcpp::shutdown();
  return 0;
}


Marker publisher:
#include <memory>
#include "rclcpp/rclcpp.hpp"
#include "visualization_msgs/msg/marker.hpp"
#include "std_msgs/msg/float32_multi_array.hpp"
#include "geometry_msgs/msg/point.hpp"

using std::placeholders::_1;

class MarkerPublisher : public rclcpp::Node
{
public:
  MarkerPublisher() : Node("marker_publisher")
  {
    marker_pub_ = this->create_publisher<visualization_msgs::msg::Marker>("visualization_marker", 10);
    re_marker_pub_ = this->create_publisher<visualization_msgs::msg::Marker>("re_visualization_marker", 10);

    subscription_ = this->create_subscription<std_msgs::msg::Float32MultiArray>(
      "/current_pose", 10, std::bind(&MarkerPublisher::topic_callback, this, _1));
  }

private:
  void topic_callback(const std_msgs::msg::Float32MultiArray::SharedPtr msg)
  {
    x_t = msg->data[0];
    y_t = msg->data[1];
    real_x = msg->data[2];
    real_y = msg->data[3];

    publish_arrow(marker_pub_, x_t, y_t, 0.0f, 1.0f, 0.0f);  // Green for estimated
    publish_arrow(re_marker_pub_, real_x, real_y, 0.0f, 0.0f, 1.0f);  // Blue for real
  }

  void publish_arrow(
    rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr pub,
    float end_x, float end_y,
    float r, float g, float b)
  {
    visualization_msgs::msg::Marker marker;
    marker.header.frame_id = "my_frame";
    marker.header.stamp = this->get_clock()->now();
    marker.ns = "basic_shapes";
    marker.id = 0;
    marker.type = visualization_msgs::msg::Marker::ARROW;
    marker.action = visualization_msgs::msg::Marker::ADD;

    marker.pose.orientation.w = 1.0;

    geometry_msgs::msg::Point start, end;
    start.x = 0.0;
    start.y = 0.0;
    start.z = 0.0;

    end.x = end_x;
    end.y = end_y;
    end.z = 0.0;

    marker.points.push_back(start);
    marker.points.push_back(end);

    marker.scale.x = 0.1;
    marker.scale.y = 0.2;
    marker.scale.z = 0.2;

    marker.color.r = r;
    marker.color.g = g;
    marker.color.b = b;
    marker.color.a = 1.0;

    marker.lifetime = rclcpp::Duration::from_nanoseconds(0);
    pub->publish(marker);
  }

  rclcpp::Subscription<std_msgs::msg::Float32MultiArray>::SharedPtr subscription_;
  rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr marker_pub_;
  rclcpp::Publisher<visualization_msgs::msg::Marker>::SharedPtr re_marker_pub_;

  float x_t = 0.0, y_t = 0.0, real_x = 0.0, real_y = 0.0;
};

int main(int argc, char **argv)
{
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MarkerPublisher>());
  rclcpp::shutdown();
  return 0;
}

